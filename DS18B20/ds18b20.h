
//библиотека с поддержкой вывода кодов ошибок
//места она занимает больше но работает быстрее (в среднем опрос датчика 8мсек вместо 12 у облегченной библиотеки)
//за счет того что она не выдерживает врямя 
//до отпускания линии датчиком, а ждет когда датчик опустит линию

//тут прописываем где сидит датчик
#define ow_in DDRC CLR_B(2)
#define ow_out DDRC SET_B(2)
#define ow_hi PORTC.2=1
#define ow_lo PORTC.2=0
#define ow_read PINC.2

#define SEARCH_ROM    0xF0 //поиск всех номеров датчиков на шине 
#define READ_ROM      0x33 //чтение номера если на шине один датчик, после команды читаем 8 байт номера датчика
#define SKIP_ROM      0xCC //если на шине один датчик то обращаемся к нему с этой команды, либо если мы хоти одновременно всем датчикам подать команду, типа запуск преобразования для всех датчиков
#define MATCH_ROM     0x55 //а если много датиков то с этой и дальше номер передаем
#define START_CONV    0x44 //запуск преобразования, можно запустить преобразование для всех датчиков, а потом через секунду считать все значения.
#define WRITE_RAM     0x4E //запись трех байт ОЗУ
#define READ_RAM      0xBE //чтение ОЗУ, после команды надо прочитать 9 байт
#define SAVE_RAM      0x48 //сохраниение ОЗУ в eeprom
#define RELOAD_RAM    0xB8 //перезагрузка ОЗУ из eeprom

#define f_ow_shortlo     10   //замыкание линии на землю
#define f_ow_shorthi     20   //замыкание линии на питание
#define f_ow_nosensor    30   //нет ни одного датчика на линии
#define f_ow_noresponse  40   //нет ответа от датчика
#define f_ow_crc         50   //ошибка контрольной суммы
#define f_ow_search      60   //ошибка поиска
#define f_ow_timeout     70   //превышение времени ответа

char ow_reset(void);//сброс шины и проверка присутствия, если устройства есть, вернет 1, если нет или КЗ на шине - 0 запишет код ошибки в переменную

void ow_write_bit(char bi); //запись бита в шину
char ow_read_bit(void);//чтение бита из шины

void ow_write_byte(char by);//запись байта в шину
char ow_read_byte(void);//чтение байта из шины
char ow_read_sequ(char *sequ, char count);//чтение необходимого количества байт в массив если сrc верное вернет 1 если нет то 0, ну мы по сути либо ром можем прочитать 8 байт, либо ОЗУ 9 байт
void ow_write_adress(char adr);//запись в шину адреса ведомого
char ow_search_rom(void);//поиск всех датчиков (максисмум 4, но масштабируется легко), возвращает число найденых датчиков, 4 датчика за 32 мсек ищет, в два раза быстрее чем родная либа CW
void ow_copy_rom(char dist);// копируеть текущий найденный ромкод

//вычисление конторольной суммы, тут идея такая - последний байт ROM
//как и последний байт RAM содержит crc и если взять crc от всех байт ROM 
//или RAM то получится 0, а если взять без последнего байта то получится 
//crc равная последнему байту. Значит если мы берем crc от всех байт 
//функция вернет 0 если данные целые
unsigned char ow_crc8(char *buffer, char size);

//возвращает температуру в десятых долях градуса с необходимого датчика 
//за 7 миллискунд отрабатывает, в отличии от родной CW функции где за 16 и прерывания почти не блокирует
//если возвращает ноль то это признак ошибки CRC, либо отсутствия датчика либо КЗ
//код ошибки пишется в переменную ow_fault, там уже точно можно посмотреть  что пошло не так
// ноль градусов будет 0.1 (1 ясен пень, в десятых долях же) отдавать, хер с ним зато удобно детектить неисправность датчика
//если подключен только один датчик чтение идет через skip rom что прилично быстрее
signed int ow_get_temp(char numb);

//делает тоже самое но с датчика последний байт romcode (там сидит CRC и скорее всего на шине не будет двух таких) совпадает с rom, это нужно для того что бы опростить конкретный датчик или убедиться в его наличии
signed int ow_get_temp_rom(char rom);



//запускает преобразование темпратуры на всех датчиках
//соотетственно читать температуру надо через секунду после запроса
//ибо преобразование идет в 12 бит
//это немного сложнее но функция не блокирует исполнение программы как родная функция CW
void ow_start_conv(void);

char rom_curr[8];//тут текущий ромкод при поиске
volatile char rom_code[4][8];//тут найденые ромкоды датчиков, если вам нужно больше датчиков то меняем первую размерность массива

char scratchpad[9];//сюда читается ОЗУ датчика
char ow_dsnumber;//количство найденых датчиков

char ow_fault;  //код ошибки
char ow_tic;//для отсчета времени ожидания отпускания линии шоб не зависнуть в цикле если линия будет в КЗ

#include "DS18B20.c"
