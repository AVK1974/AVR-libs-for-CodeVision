/*****************************************************
Project : аппаратный TWI
Version : 1.0
Date    : 24.03.2025
Author  : Antony Smith
Company : AVK inc
Comments: avkinc@gmail.com 
License : GPLv3

Chip type               : ATmega
Program type            : lib
AVR Core Clock frequency: 1-20 MHz
Memory model            : Small
External RAM size       : 0
Data Stack size         : 256
*****************************************************/

void twi_start(void);
void twi_stop(void);
void twi_wait(void);//ожидание завершения операции на шине, в случае таймаута выходит аварийно, контроллер не повесит
void twi_byte_w(char date);//пишит байт в шину
char twi_byte_r(void);//читает байт с подтверждением
char twi_byte_rn(void);//чтение байта без подтверждеия
void twi_scan(void);//сканирование всех адресов на отклик, откликнувшиеся адреса складываются в массив twi_data[], в нулевой позиции будет колчиство отозвавшихся 
char twi_ping(char adr); //прверка наи наличие на шине устройства с адресом adr, если есть возвращает 1, если нет ноль.
char twi_seq_w(char adr, char count);//пишем из массива twi_data[] с адреса adr в количестве count, адрес приемника нужно положить в twi_adr, возвращает 1 если устройство отозвалось
char twi_seq_r(char adr, char count);//читаем в массив twi_data[] с адреса adr в количестве count, адрес приемника нужно подожить в twi_adr, последний байт читается без подтверждения, возвращает 1 если устройство отозвалось

char twi_data[32];//что шлем или принимаем из i2c
char twi_fs;//статус ошибки шины
char twi_tic;//отсчет для аварийного выхода из ожидания ответа
//0xd0 ds1307 адрес
//0xA0 24C32 адрес
//0x80 PCA9685 адрес
//0x40 PCF8575 адрес
//0x90 LM75 адрес
//0x8a INA219 адрес A0 A1 подтянуты на плюс, но протеус отвечает на 0x86 хз почему
char twi_adr;

char it;//для работы с массивами

void twi_start(void)
 {
   TWCR=0;//это нужно для перезапуска блока, если произойдет КЗ на линии или еще чего, обмен остановится и больше не будет идти если ен обнулить бит TWIEN, но проще обнулить весь регистр  
   TWCR=(1<<TWINT)|(1<<TWSTA)|(1<<TWEN);//шлем старт
   twi_wait();//ждем
 }

void twi_stop(void)
 {
  TWCR=(1<<TWINT)|(1<<TWSTO)|(1<<TWEN);//засылаем стоп, тут ясно дело ждать ничо не надо
  twi_wait();//вот казалось бы ждать ненужно но если мы подряд пишем могут быть ньюансы
 }
 
void twi_wait(void)
 {
  twi_tic=0; //обнуляем счетчик времени для аварийного выхода
   while (!(TWCR&(1<<TWINT)))//ждем пока пройдет
    {
     twi_tic++;
     if(twi_tic>100)//если натикало болше ста значит чтото невпорядке и продолжать смысла нет
       {twi_fs=1; break;}
     else twi_fs=0;  
    }
 } 

void twi_byte_w(char date)
 {
   TWDR=date;//загружаем байт кторый хотим записать в шину
   TWCR=(1<<TWINT)|(1<<TWEN);//подымаем флаги на отправку
   twi_wait(); //ждем пока отправицо
 }

char twi_byte_r(void)
 {
  TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWEA);//подымаем флаги на чтение
  twi_wait();//ждем пока прочитаецо
   return TWDR; //отдаем регистр где у нас лежит принятый байт
 }

char twi_byte_rn(void)
 {
  TWCR=(1<<TWINT)|(1<<TWEN);//подымаем флаги на чтение без ASK, так читается последний байт, так ведомый понимает что усе прочитано
  twi_wait();//ждем пока прочитаецо
   return TWDR;//отдаем регистр где у нас лежит принятый байт
 }
 
 
 
char twi_seq_w(char adr, char count)
 {
   twi_start();
   twi_byte_w(twi_adr);//шлем адрес бит чтения не поднят значит запись
   if(TWSR==0x18)//и если ведомый откликнулся (в регистре статуса 0x18) то читаем дальше, а если нет то и как бы смысла нет чото писать
    { 
     twi_byte_w(adr);//шлем адрес с которого хотим писать
      for (it=0;it<count;it++)//пишем сколько хотим
       {twi_byte_w(twi_data[it]);}
      twi_stop();
      return 1;  
    }
   return 0; 
 } 

char twi_seq_r(char adr, char count)
 {
  twi_start();
  twi_byte_w(twi_adr);//шлем адрес поднимая 
  if(TWSR==0x18)//и если ведомый откликнулся (в регистре статуса 0x18) то работаем дальше, а если нет то все пропало
   { 
     twi_byte_w(adr);//шлем адрес с которого хотим читать
     twi_start();//делаем повстарт
     twi_byte_w(twi_adr+1);//и шлем адрес с битом чтения, он первый поэтому мы просто прибавляем единицу к аздесу D0, будет D1 что вполне логично
       for (it=0;it<count;it++)//и читаем сколько хотим в массив с того адреса который залали раньше
       {
         if(it==count-1)
         {twi_data[it]=twi_byte_rn();}//последний байт читаем без ASK чем говорим о заканчивании обмена
        else
         {twi_data[it]=twi_byte_r();}
       }
     twi_stop();
     return 1;//если удачно возвращаем 1 
   }
   return 0; //а если нет то 0
 }
 



void twi_scan(void)
 {
  twi_data[0]=0;//вдруг мы его не вначале запускаем, и там не ноль
  for (it=0;it<128;it++)//адресов всего 127, восьмой бит это бит записи
   {
    twi_start();
    
    twi_byte_w(it<<1);//т.к. бит записи у нас младший то мы просто сдвигаем адрес
    if(TWSR==0x18)//и если ведомый откликнулся
      {
       twi_data[twi_data[0]+1]=(it<<1);//в нулевом у нас количство найденных адресов поэтому +1
       twi_data[0]++;
      }
    twi_stop();
   } 
 }
 
 
char twi_ping(char adr)
 {  char out;
    
    twi_start();
    
    twi_byte_w(adr);//т.к. бит записи у нас младший то мы просто сдвигаем адрес
    if(TWSR==0x18)//и если ведомый откликнулся
      {
       out=1;
      }
     else out=0; 
    twi_stop();
   
   return out;  
    
 }       
 
